(* Tien Chu *)

(* Opis:
   Język funkcyjny znacznie oparty o składnię Haskella i Ocamla, w którym planuję wykonać wszystkie cechy wymienione w ścieżce funkcyjnej na 30 punktów z bonusem.

   Proste przykłady (mało, gdyż składnia jak w Haskellu/Ocamlu):
   sum a l = match l with [] -> a | h~t -> sum (a + h) l : Int -> [Int] -> Int
   foldl f z l = match l with [] -> z | h~t -> foldl f (f z h) t
*)

(* =========================================================================================================================== *)

letter = small letter | big letter

small letter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g'
      	     | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n'
	     | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u'
	     | 'v' | 'w' | 'x' | 'y' | 'z' ;

big letter = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'
       	   | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N'
       	   | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U'
       	   | 'V' | 'W' | 'X' | 'Y' | 'Z' ;

digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

symbol = '[' | ']' | '{' | '}' | '(' | ')' | '<' | '>'
       | "'" | '"' | '=' | '|' | '.' | ',' | ';' | '~'
       | '_' | '&' | '*' | '%';

bool = 'true' | 'false'

integer = [-], digit, { digit } ;

character = "'", ( letter | digit | symbol ), "'" ;

string = '"', { letter }, '"';

literal = bool | integer | character | string

binary operation = '&' | '==' | '<' | '>' | '<=' | '>=' | '!=' | '&&' | '||' | '+' | '-' | '*' | '/'
unary operation = '!', '-' ;

identifier = (letter | "'" | "_" ), { letter | "'" | "_" | digit } ;

big identifier = big letter, {identifier} ;

(* =========================================================================================================================== *)

PROGRAM = { declaration | type declaration | expression | comment | '{', PROGRAM, '}' } ;

comment = '//' | '/*' | '*/' ;

declaration = identifier, { identifier }, '=', expression, [ ':', type ] ;

type declaration = 'type', big identifier, { identifier }, '=', constructor, { '|', constructor }, [':', type] ;

constructor =  big identifier, { identifier } ;

type = type ['->' type] | constructor | '(', type, ')' | '[' type ']' ;

expression = an expression
	   | expression, expression
	   | unary operation, expression
	   | expression, binary operation, expression
	   | 'if', expression, 'then', expression, 'else', expression
     	   | 'let',  declaration, { ',', declaration }, 'in', expression
  	   | 'match' expression 'with' matching
	   | '\', pattern, {pattern}, '.', expression
	   | '[', { expression }, ']'
	   | '[', ']'
	   | '(', ')'
	   | '(expression, expression, { ',', expression })
	   | expression, 'where', declaration, { ',', declaration } ;

an expression = identifier
	      | literal
	      | '(', ')'
      	      | '(', expression, { ',', expression }, ')';
	      | expression '~' expression
	      | '[', ']'
     	      | '[', expression, { ',', expression }, ']'
	      | '[', expression, [ ',', expression ], "..", expression, ']' ;
	      | constructor, { expression } ;

pattern = '_'
	| literal
	| identifier
	| '(', ')'
	| '(', pattern, { ',', pattern }, ')' 
	| pattern, '~', pattern
	| '[', ']'
	| '[', pattern, {',', pattern } ']'
	| constructor, { pattern } ;

matching = pattern, '->', expression, { '|', pattern, '->', expression } ;
